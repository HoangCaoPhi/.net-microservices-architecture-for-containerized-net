### Sử dụng DI để inject infrastructure objects vào application layer

Như đề cập trước đó, application layer có thể triển khai như một phần của assembly bạn xây dựng, như là Web API project hoặc một MVC web app project. Trong trường hợp một microservice được xây dựng bằng ASP.NET Core, application layer sẽ thường sẽ sử dụng Web API libaray.

Nếu bạn muốn tách những gì đến từ ASP.NET Core (infrastructure cộng với controllers của bạn) ra khỏi application layer code, bạn có thể đặt application layer ở class libary riêng biệt, nhưng nó là tùy chọn.

Ví dụ, application layer code của ordering microservice trực tiếp được triển khai là một phần của Ordering.API (một ASP.NET Core Web API project) như hình 7-23:

![image.png](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/media/microservice-application-layer-implementation-web-api/ordering-api-microservice.png)

ASP.NET Core bao gồm một [built-in IoC container ](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-8.0) (được biểu thị bằng interface IServiceProvider) hỗ trợ constructor injection theo mặc định và ASP.NET cung cấp một số service nhất định thông qua DI.

ASP.NET Core sử dụng thuật ngữ service cho bất kỳ loại nào bạn đăng ký sẽ được đưa vào thông qua DI. Bạn cấu hình các built-in container's services trong ứng dụng của bạn ở file Program.cs. Các dependencies của bạn sẽ được triển khai và đăng ký trong IoC container.

Thông thường, bạn muốn inject dependencies để implement infrastructure objects. Một dependency điển hình cho việc inject là một repository. Nhưng bạn có thể inject bất kỳ infrastructure dependency khác mà bạn có. Để thực hiện nó đơn giản, bạn có thể trực tiếp inject Unit of Work pattern của bạn (EF DbContext object) bởi vì DBContext cũng được triển khai ở infrastructure persistence objects của bạn.

Trong ví dụ sau, bạn có thể thấy cách .NET đưa các đối tượng kho lưu trữ cần thiết thông qua hàm tạo. Lớp này là một command handler, sẽ được đề cập trong phần tiếp theo.

```cs
public class CreateOrderCommandHandler
        : IRequestHandler<CreateOrderCommand, bool>
{
    private readonly IOrderRepository _orderRepository;
    private readonly IIdentityService _identityService;
    private readonly IMediator _mediator;
    private readonly IOrderingIntegrationEventService _orderingIntegrationEventService;
    private readonly ILogger<CreateOrderCommandHandler> _logger;

    // Using DI to inject infrastructure persistence Repositories
    public CreateOrderCommandHandler(IMediator mediator,
        IOrderingIntegrationEventService orderingIntegrationEventService,
        IOrderRepository orderRepository,
        IIdentityService identityService,
        ILogger<CreateOrderCommandHandler> logger)
    {
        _orderRepository = orderRepository ?? throw new ArgumentNullException(nameof(orderRepository));
        _identityService = identityService ?? throw new ArgumentNullException(nameof(identityService));
        _mediator = mediator ?? throw new ArgumentNullException(nameof(mediator));
        _orderingIntegrationEventService = orderingIntegrationEventService ?? throw new ArgumentNullException(nameof(orderingIntegrationEventService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task<bool> Handle(CreateOrderCommand message, CancellationToken cancellationToken)
    {
        // Add Integration event to clean the basket
        var orderStartedIntegrationEvent = new OrderStartedIntegrationEvent(message.UserId);
        await _orderingIntegrationEventService.AddAndSaveEventAsync(orderStartedIntegrationEvent);

        // Add/Update the Buyer AggregateRoot
        // DDD patterns comment: Add child entities and value-objects through the Order Aggregate-Root
        // methods and constructor so validations, invariants and business logic
        // make sure that consistency is preserved across the whole aggregate
        var address = new Address(message.Street, message.City, message.State, message.Country, message.ZipCode);
        var order = new Order(message.UserId, message.UserName, address, message.CardTypeId, message.CardNumber, message.CardSecurityNumber, message.CardHolderName, message.CardExpiration);

        foreach (var item in message.OrderItems)
        {
            order.AddOrderItem(item.ProductId, item.ProductName, item.UnitPrice, item.Discount, item.PictureUrl, item.Units);
        }

        _logger.LogInformation("----- Creating Order - Order: {@Order}", order);

        _orderRepository.Add(order);

        return await _orderRepository.UnitOfWork
            .SaveEntitiesAsync(cancellationToken);
    }
}
```

Lớp này sử dụng để njected repositories thực thi transaction và persist những state changes. Không quan trọng lớp đó có phải là command handler hay không, một ASP.NET Core Web API controller method hoặc một [ DDD Application Service](https://lostechies.com/jimmybogard/2008/08/21/services-in-domain-driven-design/) cuối cùng nó là một lớp đơn giản sử dụng repositories, domain entities và phối hợp các ứng dụng khác theo các tương tự một command handler. Dependency Injection làm việc theo cách tương tự tất cả các lớp đã được đề cập, như trong ví dụ sử dụng DI dựa trên hàm tạo.

### Đăng ký dependency implementation types với interfaces hoặc abstractions

Trước khi bạn sử dụng objects injected thông qua constructors, bạn cần biết đăng ký interface và lớp implement của nó được đăng ký ở đâu. (Giống như DI dựa trên hàm tạo, như được hiển thị trước đó).

### Sử dụng built-in IoC container cung cấp bởi ASP.NET Core

Khi bạn sử dụng built-in IoC container cung cấp bởi ASP.NET Core, bạn đăng ký types bạn muốn inject ở trong file Program.cs như đoạn code sau:

```cs
// Register out-of-the-box framework services.
builder.Services.AddDbContext<CatalogContext>(c =>
    c.UseSqlServer(Configuration["ConnectionString"]),
    ServiceLifetime.Scoped);

builder.Services.AddMvc();
// Register custom application dependencies.
builder.Services.AddScoped<IMyCustomRepository, MyCustomSQLRepository>();
```

Pattern phổ biến khi đăng ký types trong một IoC container là đăng ký một cặp types là một interface và một lớp implement liên quan đến nó. Sau đó, bạn yêu cầu một đối tượng từ IoC container thông qua bất kỳ constructor nào, bạn yêu cầu một đối tượng của một interface nhất định. Ví dụ, trong ví dụ trước bất kỳ hàm tạo nào có một dependency trên IMyCustomRepository, IoC container sẽ inject một instance của lớp MyCustomSQLServerRepository.

### Sử dụng Scrutor library để đăng ký automatic types

Khi sử dụng DI trong .NET, bạn có thể muốn quét một assembly và tự động đăng ký các loại của nó theo convention.

Tính năng này hiện không có sẵn trong ASP.NET Core. Tuy nhiên, bạn có thể sử dụng thư viện Scrutor cho việc đó. Cách tiếp cận này thuận tiện khi bạn có hàng tá loại cần được đăng ký trong vùng chứa IoC của mình.

Tài nguyên bổ sung

Matthew King. Registering services with Scrutor
https://www.mking.net/blog/registering-services-with-scrutor

Kristian Hellang. Scrutor. GitHub repo.
https://github.com/khellang/Scrutor

### Sử dụng Autofac là một IoC container

Bạn cũng có thể sử dụng thêm IoC containers và cài chúng vào trong ASP.NET Core pipeline, như trong ordering microservice, chúng tôi sử dụng Autofac. Sử dụng Autofac với ASP.NET Core cung cấp sự kiểm soát nâng cao đối với dependency injection và cho phép bạn tách logic đăng ký vào nhiều tệp hoặc thư viện bằng cách sử dụng các module. Cách tiếp cận module này giúp tổ chức và bảo trì các phụ thuộc của ứng dụng dễ dàng hơn, đặc biệt khi ứng dụng ngày càng phức tạp.

Ví dụ: sau đây là mô-đun ứng dụng Autofac cho dự án API Web Ordering.API với các loại bạn sẽ muốn đưa vào.

```cs
public class ApplicationModule : Autofac.Module
{
    public string QueriesConnectionString { get; }
    public ApplicationModule(string qconstr)
    {
        QueriesConnectionString = qconstr;
    }

    protected override void Load(ContainerBuilder builder)
    {
        builder.Register(c => new OrderQueries(QueriesConnectionString))
            .As<IOrderQueries>()
            .InstancePerLifetimeScope();
        builder.RegisterType<BuyerRepository>()
            .As<IBuyerRepository>()
            .InstancePerLifetimeScope();
        builder.RegisterType<OrderRepository>()
            .As<IOrderRepository>()
            .InstancePerLifetimeScope();
        builder.RegisterType<RequestManager>()
            .As<IRequestManager>()
            .InstancePerLifetimeScope();
   }
}
```

Autofac còn có tính năng scan assenblíe và đăng ký các types theo quy ước tên.

Quá trình đăng ký và các khái niệm rất giống với cách bạn có thể đăng ký các types với IoC container của ASP.NET Core tích hợp sẵn, nhưng cú pháp khi sử dụng Autofac hơi khác một chút.

Trong mã ví dụ, IOrderRepository trừu tượng được đăng ký cùng với lớp triển khai OrderRepository. Điều này có nghĩa là bất cứ khi nào một hàm tạo khai báo một phần phụ thuộc thông qua interface IOrderRepository, bộ chứa IoC container inject một instance của lớp OrderRepository.

Tài nguyên bổ sung

Introduction to Dependency Injection in ASP.NET Core
https://learn.microsoft.com/aspnet/core/fundamentals/dependency-injection

Autofac. Official documentation.
https://docs.autofac.org/en/latest/

Comparing ASP.NET Core IoC container service lifetimes with Autofac IoC container instance scopes - Cesar de la Torre.
https://devblogs.microsoft.com/cesardelatorre/comparing-asp-net-core-ioc-service-life-times-and-autofac-ioc-instance-scopes/

### Triển khai Command và ommand Handler patterns

Trong ví dụ về DI-through-constructor được trình bày ở phần trước, bộ chứa IoC đang injecting repositories thông qua một hàm tạo trong một lớp. Nhưng chính xác là chúng được injected vào đâu? Trong một API Web đơn giản (ví dụ: microservice catalog trong eShopOnContainers), bạn inject chúng vào MVC controllers' level, trong controller constructor, như một phần của request pipeline của ASP.NET Core. Trong đoạn code của phần đầu tiên (lớp [ CreateOrderCommandHandler](https://github.com/dotnet-architecture/eShopOnContainers/blob/main/src/Services/Ordering/Ordering.API/Application/Commands/CreateOrderCommandHandler.cs) từ Ordering.API service trong eShopOnContainers), việc inject thông qua constructor là một phần của command handler. Chúng ta sẽ giải thích command handler là gì và tại sao lại sử dụng nó.

Command pattern là một pattern về bản chất liên quan đến CQRS pattern đã giới thiệu ở trước đó. CQRS có hai sides. Đầu tiên là khu vực cho queries, sử dụng queries đơn giản với Dapper micro ORM đã giải thích ở trước đó. Thứ hai là commands, là điểm bắt đầu cho các transactions, và là kênh đầu vào từ bên ngoài service.

Như trong hình 7-24, pattern dựa trên việc chấp nhận các commands từ client-side, xử lý chúng dựa trên domain model rules, và cuối cùng persisting states với transactions.

![image.png](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/media/microservice-application-layer-implementation-web-api/high-level-writes-side.png)

Hình 7-24 cho thấy ứng dụng UI gửi Command thông qua API tới CommandHandler, Command này phụ thuộc vào Domain model và Infrastructure để cập nhật cơ sở dữ liệu.

### Command class

Một command là một yêu cầu đến hệ thống thực hiện một hành động thay đổi trạng thái của hệ thống. Đây là những yêu cầu cụ thể, có tính chất mệnh lệnh và chỉ nên được xử lý một lần.

Vì commands có tính chất mệnh lệnh, nên chúng thông thường có tên với một động từ ở thể mệnh lệnh (ví dụ, "create" hoặc "update"), và chúng có thể bao gồm aggregate type, như là CreateOrderCommand. Không giống event, nó không phải là một hành động đã xảy ra trong quá khứ, nó chỉ là một request và có thể bị refused.

Commands có thể xuất phát từ hai nguồn chính trong một hệ thống phần mềm:

- Giao diện người dùng (UI):
  Commands có thể được khởi tạo từ UI khi người dùng thực hiện một hành động. Ví dụ, khi người dùng nhấn nút "Đặt hàng" trên trang web, một command sẽ được tạo ra để yêu cầu hệ thống tạo đơn hàng mới.
- Process Manager:
  Commands cũng có thể được tạo ra từ một process manager (còn gọi là saga). Process manager là một thành phần điều phối các hành động giữa các aggregates khác nhau. Khi process manager yêu cầu một aggregate thực hiện một hành động cụ thể, nó sẽ tạo ra và gửi command đó.

Một đặc điểm quan trọng của command là nó chỉ được xử lý một lần bởi một người nhận. Điều này là do command là một hành động hoặc giao dịch đơn lẻ mà bạn muốn thực hiện trong ứng dụng. Ví dụ: cùng một lệnh tạo đơn hàng không được xử lý nhiều lần. Đây là sự khác biệt quan trọng giữa command và event. Các events có thể được xử lý nhiều lần vì nhiều hệ thống hoặc vi dịch vụ có thể quan tâm đến event này.

Ngoài ra, điều quan trọng là một command chỉ được xử lý một lần trong trường hợp lệnh đó idempotent. Một command là idempotent nếu nó có thể được thực thi nhiều lần mà không thay đổi kết quả, do tính chất của command hoặc do cách hệ thống xử lý command.

Đó là một cách thực hành tốt để làm cho các commands và update của bạn trở nên idempotent khi nó có ý nghĩa theo các domain's business rules và invariants trong miền của bạn. Ví dụ: để sử dụng cùng một ví dụ, nếu vì bất kỳ lý do nào (retry logic, hacking, etc.), cùng một CreateOrder command đến hệ thống của bạn nhiều lần, bạn phải có thể xác định lệnh đó và đảm bảo rằng bạn không tạo nhiều đơn hàng. Để làm như vậy, bạn cần đính kèm một số loại nhận dạng trong các hoạt động và xác định xem command hoặc update đã được xử lý chưa.

Bạn gửi command đến một người nhận; bạn không publish một command. Publishing dành cho events (một điều gì đó đã xảy ra và những người nhận là những người có thể quan tâm đến events đó). Trong trường hợp events, publisher không cần bận tâm về receivers nào nhận nó và họ làm gì với chúng. Nhưng domain hoặc integration events thì là một câu chuyện khác đã được giới thiệu ở phần trước.

Một command được triển khai bằng một lớp chứa data fields hoặc collections với tất cả thông tin cần để thực thi một command. Một command là một Data Transfer Object (DTO) đặc biệt, được sử dụng cụ thể để yêu cầu thay đổi hoặc giao dịch. Bản thân command dựa trên những thông tin cần thiết để xử lý command, và không làm gì nhiều hơn.

Ví dụ sau đây cho thấy lớp CreateOrderCommand đơn giản. Đây là một immutable command được sử dụng trong ordering microservice trong eShopOnContainers.

```cs
// DDD and CQRS patterns comment: Note that it is recommended to implement immutable Commands
// In this case, its immutability is achieved by having all the setters as private
// plus only being able to update the data just once, when creating the object through its constructor.
// References on Immutable Commands:
// http://cqrs.nu/Faq
// https://docs.spine3.org/motivation/immutability.html
// http://blog.gauffin.org/2012/06/griffin-container-introducing-command-support/
// https://learn.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-a-lightweight-class-with-auto-implemented-properties

[DataContract]
public class CreateOrderCommand
    : IRequest<bool>
{
    [DataMember]
    private readonly List<OrderItemDTO> _orderItems;

    [DataMember]
    public string UserId { get; private set; }

    [DataMember]
    public string UserName { get; private set; }

    [DataMember]
    public string City { get; private set; }

    [DataMember]
    public string Street { get; private set; }

    [DataMember]
    public string State { get; private set; }

    [DataMember]
    public string Country { get; private set; }

    [DataMember]
    public string ZipCode { get; private set; }

    [DataMember]
    public string CardNumber { get; private set; }

    [DataMember]
    public string CardHolderName { get; private set; }

    [DataMember]
    public DateTime CardExpiration { get; private set; }

    [DataMember]
    public string CardSecurityNumber { get; private set; }

    [DataMember]
    public int CardTypeId { get; private set; }

    [DataMember]
    public IEnumerable<OrderItemDTO> OrderItems => _orderItems;

    public CreateOrderCommand()
    {
        _orderItems = new List<OrderItemDTO>();
    }

    public CreateOrderCommand(List<BasketItem> basketItems, string userId, string userName, string city, string street, string state, string country, string zipcode,
        string cardNumber, string cardHolderName, DateTime cardExpiration,
        string cardSecurityNumber, int cardTypeId) : this()
    {
        _orderItems = basketItems.ToOrderItemsDTO().ToList();
        UserId = userId;
        UserName = userName;
        City = city;
        Street = street;
        State = state;
        Country = country;
        ZipCode = zipcode;
        CardNumber = cardNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
        CardSecurityNumber = cardSecurityNumber;
        CardTypeId = cardTypeId;
        CardExpiration = cardExpiration;
    }


    public class OrderItemDTO
    {
        public int ProductId { get; set; }

        public string ProductName { get; set; }

        public decimal UnitPrice { get; set; }

        public decimal Discount { get; set; }

        public int Units { get; set; }

        public string PictureUrl { get; set; }
    }
}
```

Về cơ bản, command class chứa tất cả data bạn cần để thực hiện một business transaction bằng cách sử dụng domain model objects. Vì vậy, commands đơn giản là một data structures chứa read-only data, và không có behavior. Command's name cho biết mục đích của nó. Trong nhiều ngôn ngữ như C#, commands được biểu diễn dưới dạng các lớp, nhưng chúng không phải là các lớp thực sự theo nghĩa hướng đối tượng.

Thêm một đặc điểm nữa là, commands là immutable, bởi vì mục đích sử dụng dự kiến là chúng được domain model xử lý trực tiếp. Chúng không cần phải thay đổi trong suốt thời gian tồn tại dự kiến của chúng. Trong lớp C#, immutability có thể đạt được bằng cách không có bất kỳ setters hoặc phương thức nào khác thay đổi trạng thái bên trong.

Hãy nhớ rằng nếu bạn dự định hoặc mong đợi các lệnh sẽ trải qua quá trình serializing/deserializing thì các thuộc tính phải có một private setter và thuộc tính [DataMember] (hoặc [JsonProperty]). Nếu không, deserializer sẽ không thể xây dựng lại đối tượng tại đích với các giá trị được yêu cầu. Bạn cũng có thể sử dụng các thuộc tính read-only nếu lớp có một hàm tạo với các tham số cho tất cả các thuộc tính, với quy ước đặt tên CamelCase thông thường và chú thích hàm tạo đó là [JsonConstructor]. Tuy nhiên, tùy chọn này yêu cầu nhiều mã hơn.

Ví dụ: lớp command để tạo đơn hàng có thể tương tự về mặt dữ liệu với đơn hàng bạn muốn tạo, nhưng có thể bạn không cần các thuộc tính giống nhau. Ví dụ: CreateOrderCommand không có ID đơn hàng vì đơn hàng chưa được tạo.

Nhiều lớp command có thể đơn giản, chỉ yêu cầu một vài trường về một số trạng thái cần thay đổi. Trường hợp đó xảy ra nếu bạn chỉ thay đổi trạng thái của đơn hàng từ "đang xử lý" thành "đã thanh toán" hoặc "đã giao hàng" bằng cách sử dụng command tương tự như sau:

```cs
[DataContract]
public class UpdateOrderStatusCommand
    :IRequest<bool>
{
    [DataMember]
    public string Status { get; private set; }

    [DataMember]
    public string OrderId { get; private set; }

    [DataMember]
    public string BuyerIdentityGuid { get; private set; }
}
```

Một số nhà phát triển tách biệt các đối tượng yêu cầu giao diện người dùng khỏi DTO lệnh của họ, nhưng đó chỉ là vấn đề ưu tiên. Đó là một sự tách biệt tẻ nhạt, không có nhiều giá trị bổ sung và các đối tượng như có hình dạng giống hệt nhau.

Ví dụ: trong eShopOnContainers, một số commands đến trực tiếp từ phía máy khách.

### Command handler class

Bạn nên triển khai một lớp command handler cụ thể cho mỗi command. Đó là cách pattern này hoạt động, và đó là nơi bạn sử dụng object command, domain objects và  infrastructure repository objects. Command handler là trái tim của application layer trong ngữ cảnh CQRS và DDD. Tuy nhiên, tất cả domain logic phải chứa trong các domain logic - trong  aggregate roots (root entities), child entities hoặc [domain services](https://lostechies.com/jimmybogard/2008/08/21/services-in-domain-driven-design/), nhưng không ở trong command handler, đó là một lớp từ application layer.

Lớp Command handler cung cấp một bước đệm vững chắc để đạt được Single Responsibility Principle (SRP) như đã đề cập ở phần trước đó.

Một command handler nhận một command và đạt được kết quá từ aggregate được sử dụng. Kết quả trả về sẽ là thực thi thành công một command hoặc một exception. Trong trường hợp ngoại lệ, trạng thái hệ thống sẽ không thay đổi.

Command handler thường thực hiện các bước như sau:

- Nhận một  command object như một DTO (từ mediator hoặc infrastructure object khác).

- Nó validates  rằng command  là hợp lệ (nếu không được mediator validated).

- Nó khởi tạo aggregate root instance là mục tiêu của command hiện tại.

- Nó thực thi phương thức trên aggregate root instance, lấy dữ liệu cần thiết từ command.

- Nó persists trạng thái mới của aggregate để lưu vào related database. Hoạt động cuối cùng là save transaction.


Thông thường, một  command handler xử lý duy nhất một aggregate nhận được từ  aggregate root (root entity) của nó. Nếu có nhiều aggregates bị ảnh hưởng bởi duy nhất một command, bạn có thể sử dụng  domain events để truyền states hoặc actions thông qua nhiều aggregates.

Điểm quan trọng ở đây là khi command được thực thi, tất cả domain logic phải ở bên trong domain model (the aggregates), đóng gói đầy đủ và sẵn sàng cho unit testing. Command handler chỉ hoạt động như một cách lấy domain model từ database, và bước cuối cùng, gọi đến infrastructure layer (repositories) để persist những thay đổi khi model thay đổi. Ưu điểm của phương pháp này là bạn có thể refactor domain logic một cách độc lập, đóng gói và đầy đủ, rich, behavioral domain model mà không thay đổi code ở application hoặc infrastructure layers, nó ở là plumbing level (command handlers, Web API, repositories, etc.)

Khi command handlers trở nên phức tạp, có quá nhiều logic, nó có thể trở nên thành code smell. Xem xét chúng, nếu bạn tìm thấy domain logic,  refactor code và di chuyển chúng vào domain behavior method ở trong domain objects (aggregate root hoặc child entity).

Sau đây là ví dụ về CreateOrderCommandHandler là handler của CreateOrderCommand ở phía trên:

```cs
public class CreateOrderCommandHandler
        : IRequestHandler<CreateOrderCommand, bool>
{
    private readonly IOrderRepository _orderRepository;
    private readonly IIdentityService _identityService;
    private readonly IMediator _mediator;
    private readonly IOrderingIntegrationEventService _orderingIntegrationEventService;
    private readonly ILogger<CreateOrderCommandHandler> _logger;

    // Using DI to inject infrastructure persistence Repositories
    public CreateOrderCommandHandler(IMediator mediator,
        IOrderingIntegrationEventService orderingIntegrationEventService,
        IOrderRepository orderRepository,
        IIdentityService identityService,
        ILogger<CreateOrderCommandHandler> logger)
    {
        _orderRepository = orderRepository ?? throw new ArgumentNullException(nameof(orderRepository));
        _identityService = identityService ?? throw new ArgumentNullException(nameof(identityService));
        _mediator = mediator ?? throw new ArgumentNullException(nameof(mediator));
        _orderingIntegrationEventService = orderingIntegrationEventService ?? throw new ArgumentNullException(nameof(orderingIntegrationEventService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task<bool> Handle(CreateOrderCommand message, CancellationToken cancellationToken)
    {
        // Add Integration event to clean the basket
        var orderStartedIntegrationEvent = new OrderStartedIntegrationEvent(message.UserId);
        await _orderingIntegrationEventService.AddAndSaveEventAsync(orderStartedIntegrationEvent);

        // Add/Update the Buyer AggregateRoot
        // DDD patterns comment: Add child entities and value-objects through the Order Aggregate-Root
        // methods and constructor so validations, invariants and business logic
        // make sure that consistency is preserved across the whole aggregate
        var address = new Address(message.Street, message.City, message.State, message.Country, message.ZipCode);
        var order = new Order(message.UserId, message.UserName, address, message.CardTypeId, message.CardNumber, message.CardSecurityNumber, message.CardHolderName, message.CardExpiration);

        foreach (var item in message.OrderItems)
        {
            order.AddOrderItem(item.ProductId, item.ProductName, item.UnitPrice, item.Discount, item.PictureUrl, item.Units);
        }

        _logger.LogInformation("----- Creating Order - Order: {@Order}", order);

        _orderRepository.Add(order);

        return await _orderRepository.UnitOfWork
            .SaveEntitiesAsync(cancellationToken);
    }
}
```

Đây là những bước bổ sung mà một command handler nên thực hiện:

- Sử dụng command data để làm việc với aggregate root's methods và behavior.

- Bên trong domain objects,  raise domain events trong khi transaction được thực thi, nhưng điều đó phải minh bạch theo quan điểm của command handler.

- Nếu kết quả thao tác trên aggregate's thành công, sau khi transaction thành công, raise integration events. (chúng có thể raised bởi infrastructure classes như repositories)

Tài nguyên bổ sung

Mark Seemann. At the Boundaries, Applications are Not Object-Oriented
https://blog.ploeh.dk/2011/05/31/AttheBoundaries,ApplicationsareNotObject-Oriented/

Commands and events
https://cqrs.nu/faq/Command%20and%20Events

What does a command handler do?
https://cqrs.nu/faq/Command%20Handlers

Jimmy Bogard. Domain Command Patterns – Handlers
https://jimmybogard.com/domain-command-patterns-handlers/

Jimmy Bogard. Domain Command Patterns – Validation
https://jimmybogard.com/domain-command-patterns-validation/

### Command process pipeline, trigger một command handler như thế nào???

Câu hỏi tiếp theo là làm sao có thể invoke một command handler. Bạn có thể gọi nó theo cách thủ công từ ASP.NET Core controller có liên quan. Tuy nhiên, cách tiếp cận đó sẽ quá coupled và không lý tưởng.

Có hai options chính khác, đây là những lựa chọn đề xuất: 

+ Thông qua một in-memory Mediator pattern.

+ Với một synchronous message queue, giữa controllers và handlers.

### Sử dụng Mediator pattern (in-memory) trong command pipeline

Như trong hình 7-25, trong cách tiếp cận CQRS bạn sử dụng một  intelligent mediator, tương tự như một in-memory bus, nó đủ thông minh để điều hướng đến command handler based dựa trên type của command hoặc DTO nhận được. Các mũi tên màu đen duy nhất giữa các thành phần đại diện cho sự phụ thuộc giữa chúng (trong nhiều trường hợp, được injected thông qua DI) với những tương tác liên quan giữa chúng.

![image.png](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/media/microservice-application-layer-implementation-web-api/mediator-cqrs-microservice.png)

Lý do sử dụng Mediator pattern có ý nghĩa trong enterprise applications, các yêu cầu xử lý có thể trở nên phức tạp. Bạn muốn có thể bổ sung thêm một số mối quan tâm xuyên suốt như logging, validations, audit và security. Trong những trường hợp này, bạn có thể dựa vào mediator pipeline (xem [mediator](https://en.wikipedia.org/wiki/Mediator_pattern)) để cung cấp phương tiện cho những hành vi bổ sung hoặc mối quan tâm xuyên suốt này.

Một mediator là một đối tượng gói gọn cách thức của quá trình này, nó điều phối việc thực thi dựa trên state, cách mà command handler được invoked, hoặc payload của bạn cung cấp cho handler. Với một mediator component, bạn có thể áp dụng mối quan tâm xuyên suốt một cách tập trung và minh bạch bằng cách áp dụng decorators (hoặc [pipeline behaviors](https://github.com/jbogard/MediatR/wiki/Behaviors)) từ [MediatR 3](https://www.nuget.org/packages/MediatR/3.0.0). Để biết thêm thông tin, xem xét về [Decorator pattern](https://en.wikipedia.org/wiki/Decorator_pattern).

Decorators và behaviors tương tự như [Aspect Oriented Programming (AOP)](https://en.wikipedia.org/wiki/Aspect-oriented_programming), chỉ áp dụng một process pipeline cụ thể được quản lý bởi mediator component. 

Ví dụ, trong eShopOnContainers ordering microservice, có triển khai hai sample behaviors, một  lớp [LogBehavior](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/Behaviors/LoggingBehavior.cs) và một lớp  [ValidatorBehavior](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/Behaviors/ValidatorBehavior.cs).  Việc triển khai các behaviors  được giải thích trong phần tiếp theo bằng cách chỉ ra cách eShopOnContainers sử dụng các MediatR behaviors.

### Sử dụng message queues (out-of-proc) trong command's pipeline

Một lựa chọn khác là sử dụng  asynchronous messages based dựa vào brokers  hoặc message queues, như hình  7-26. Hành động đó có thể kết hợp với mediator component ngay trước command handler.

![image.png](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/media/microservice-application-layer-implementation-web-api/add-ha-message-queue.png)

Command's pipeline cũng có thể xử lý một cách high availability message queue để gửi commands đến handler thích hợp. Sử dụng message queues để chấp nhận command có thể làm phức tạp  command's pipeline của bạn, bởi vì nó có thể chia pipeline thành hai processes kết nối thông qua một external message queue. Tuy nhiên, nó vẫn nên sử dụng nếu bạn cần cải thiện khả năng mở rộng và performance dựa trên asynchronous messaging.

Hãy xem xét trong trường hợp hình 7-26, controller vừa posts command message vào queue và trả về. Sau đó command handlers sẽ được xử lý dựa vào messages chúng nhận được, Đây là lợi ích tốt của queue: message queue có thể hoạt động như là một buffer trong trường hợp cần phải có khả năng mở rộng cao, như là hệ thống chứng khoán hoặc bất kỳ kịch bản nào khác mà dữ liệu đầu vào có khối lượng lớn.

Tuy nhiên, do tính chất bất đồng bộ của message queues, bạn cần tìm ra cách giao tiếp với client application về sự thành công hay thất bại của command's process. Theo quy tắc, bạn không bao giờ được sử dụng "fire and forget". Mọi  business application cần biết command có xử lý thành công hay không, hoặc ít nhất là được validated và accepted.

Do đó, việc có thể có khả năng phản hồi về client sau khi  validating 1 command message được submitted bởi một asynchronous queue làm tăng độ phức tạp cho hệ thống của bạn, so với việc sử dụng in-process command process nó sẽ trả về kết quả sau khi chạy transaction. Sử dụng queues, bạn cần trả về kết quả của command process thông qua một hoạt động thông báo kết quả khác, điều này sẽ yêu cầu thêm các thành phần bổ sung và giao tiếp trong hệ thống của bạn.

Ngoài ra,  async commands là commands một chiều, mà trong nhiều trường hợp có thể không cần thiết, điều này được giải thích trong cuộc trò chuyện rất thú vị giữa Burtsev Alexey và Greg Young như sau:

[Burtsev Alexey] I find lots of code where people use async command handling or one-way command messaging without any reason to do so (they are not doing some long operation, they are not executing external async code, they do not even cross-application boundary to be using message bus). Why do they introduce this unnecessary complexity? And actually, I haven't seen a CQRS code example with blocking command handlers so far, though it will work just fine in most cases.

[Greg Young] [...] an asynchronous command doesn't exist; it's actually another event. If I must accept what you send me and raise an event if I disagree, it's no longer you telling me to do something [that is, it's not a command]. It's you telling me something has been done. This seems like a slight difference at first, but it has many implications.

Asynchronous commands làm tăng đáng kể độ phức tạp của hệ thống, bởi vì không có cách đơn giản nào thông báo khi failures. Vì vậy,  asynchronous commands  không được recommended ngoại trừ trường hợp scaling là việc cần thiết hoặc trong các trường hợp đặc biệt khi các  internal microservices  giao tiếp với nhau thông qua messaging. Trong những trường hợp đó, bạn phải thiết kế một hệ thống reporting  và recovery system khi bị lỗi riêng biệt.

Trong phiên bản đầu tiên của eShopOnContainers, nó quyết định sử dụng synchronous command processing, bắt đầu từ HTTP requests và được điều khiển bởi Mediator pattern. Điều đó dễ dàng cho phép bạn trả về thành công hay thất bại của quy trình, như trong quá trình triển khai [CreateOrderCommandHandler](https://github.com/dotnet-architecture/eShopOnContainers/blob/netcore1.1/src/Services/Ordering/Ordering.API/Application/Commands/CreateOrderCommandHandler.cs).

Trong mọi trường hợp, điều đó phải được quyết định dựa trên application's hoặc microservice's business requirements.

### Triển khai command process pipeline với một mediator pattern (MediatR)

Hướng dẫn này khuyến nghị sử dụng in-process pipeline dựa trên Mediator pattern để nhận các command và đưa đến command handler tương ứng. Hướng dẫn này cũng đề xuất áp dụng [behaviors](https://github.com/jbogard/MediatR/wiki/Behaviors) để separate cross-cutting concerns.

Thư viện được sử dụng là [MediatR](https://github.com/jbogard/MediatR) (tạo bởi Jimmy Bogard), nhưng bạn có thể lựa chọn cách tiếp cận khác nếu muốn. MediatR là một thư viện nhỏ và đơn giản, cho phép bạn  process in-memory messages như một command, trong khi áp dụng decorators hoặc behaviors.

Sử dụng Mediator pattern giúp bạn giảm coupling và độc lập với các mối bận tâm về requested work, trong khi tự động kết nối với handler và thực hiện công việc đó - trong trường hợp này, nó là command handlers.

Một lý do khác sử dụng Mediator pattern được giải thích bởi Jimmy Bogard:

I think it might be worth mentioning testing here – it provides a nice consistent window into the behavior of your system. Request-in, response-out. We've found that aspect quite valuable in building consistently behaving tests.

()

Trước tiên, hãy nhìn sample WebAPI controller, nơi bạn sẽ thực sự sử dụng mediator object. Nếu bạn không sử dụng mediator object, bạn cần inject tất cả dependencies ở controller như logger object và những đối tượng khác. Vì vậy, hàm tạo sẽ trở nên phức tạp. Mặt khác, nếu bạn sử dụng mediator object, constructor của controller có thể đơn giản hơn rất nhiều, với chỉ một vài dependencies thay vì rất nhiều dependencies nếu bạn có một cái cho mỗi hành động xuyên suốt, như trong ví dụ sau:

```cs
public class MyMicroserviceController : Controller
{
    public MyMicroserviceController(IMediator mediator,
                                    IMyMicroserviceQueries microserviceQueries)
    {
        // ...
    }
}
```

Bạn có thể thấy rằng mediator cung cấp một Web API controller constructor rõ ràng và gọn gàng. Ngoài ra trong các phương thức của controller , code send một command  đến mediator object cũng gần như chỉ cần một dòng:

```cs
[Route("new")]
[HttpPost]
public async Task<IActionResult> ExecuteBusinessOperation([FromBody]RunOpCommand
                                                               runOperationCommand)
{
    var commandResult = await _mediator.SendAsync(runOperationCommand);

    return commandResult ? (IActionResult)Ok() : (IActionResult)BadRequest();
}
```

### Triển khai idempotent Commands

Trong eShopOnContainers, một ví dụ nâng cao hơn ví dụ trên là gửi một CreateOrderCommand object từ  Ordering microservice. Nhưng vì Ordering business process phức tạp hơn một chút và trong trường hợp của chúng ta, nó thực sự bắt đầu trong Basket microservice, hành động gửi một CreateOrderCommand    object là thực hiện từ một integration-event handler tên là [UserCheckoutAcceptedIntegrationEventHandler](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/IntegrationEvents/EventHandling/UserCheckoutAcceptedIntegrationEventHandler.cs) thay vì một simple WebAPI controller đơn giản được gọi từ client App như ở ví dụ trước.

Tuy nhiên, hành động gửi Command  tới MediatR khá giống nhau, như được hiển thị trong đoạn mã sau.

```cs
var createOrderCommand = new CreateOrderCommand(eventMsg.Basket.Items,
                                                eventMsg.UserId, eventMsg.City,
                                                eventMsg.Street, eventMsg.State,
                                                eventMsg.Country, eventMsg.ZipCode,
                                                eventMsg.CardNumber,
                                                eventMsg.CardHolderName,
                                                eventMsg.CardExpiration,
                                                eventMsg.CardSecurityNumber,
                                                eventMsg.CardTypeId);

var requestCreateOrder = new IdentifiedCommand<CreateOrderCommand,bool>(createOrderCommand,
                                                                        eventMsg.RequestId);
result = await _mediator.Send(requestCreateOrder);
```

Tuy nhiên, trường hợp này cũng nâng cao hơn một chút vì chúng tôi cũng đang triển khai các  idempotent commands. Quá tình CreateOrderCommand phải là một idempotent, vì vậy nếu cùng một message  được duplicated  qua network, vì bất kỳ lý do gì, chẳng hạn như thử lại, lệnh business order sẽ chỉ được xử lý một lần.

Điều này được thực hiện bằng cách wrapping lại business command (trong trường hợp này là CreateOrderCommand) và nhúng nó vào một IdentifiedCommand, được theo dõi bởi ID của mọi message đến thông qua network phải là idempotent.

Trong đoạn code dưới đây, IdentifiedCommand không có gì nhiều hơn là một DTO với một ID để wrapped business command object.

```cs
public class IdentifiedCommand<T, R> : IRequest<R>
    where T : IRequest<R>
{
    public T Command { get; }
    public Guid Id { get; }
    public IdentifiedCommand(T command, Guid id)
    {
        Command = command;
        Id = id;
    }
}
```

Sau đó, CommandHandler cho IdentifiedCommand có tên [IdentifiedCommandHandler.cs](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/Commands/IdentifiedCommandHandler.cs) về cơ bản sẽ kiểm tra xem ID đến như một phần của message đã tồn tại trong một table hay chưa. Nếu đã tồn tại command sẽ không xử lý lại, vì vậy nó là  idempotent command. Infrastructure code được thực hiện bởi phương thức _requestManager.ExistAsync ở phía dưới. 

```cs
// IdentifiedCommandHandler.cs
public class IdentifiedCommandHandler<T, R> : IRequestHandler<IdentifiedCommand<T, R>, R>
        where T : IRequest<R>
{
    private readonly IMediator _mediator;
    private readonly IRequestManager _requestManager;
    private readonly ILogger<IdentifiedCommandHandler<T, R>> _logger;

    public IdentifiedCommandHandler(
        IMediator mediator,
        IRequestManager requestManager,
        ILogger<IdentifiedCommandHandler<T, R>> logger)
    {
        _mediator = mediator;
        _requestManager = requestManager;
        _logger = logger ?? throw new System.ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Creates the result value to return if a previous request was found
    /// </summary>
    /// <returns></returns>
    protected virtual R CreateResultForDuplicateRequest()
    {
        return default(R);
    }

    /// <summary>
    /// This method handles the command. It just ensures that no other request exists with the same ID, and if this is the case
    /// just enqueues the original inner command.
    /// </summary>
    /// <param name="message">IdentifiedCommand which contains both original command & request ID</param>
    /// <returns>Return value of inner command or default value if request same ID was found</returns>
    public async Task<R> Handle(IdentifiedCommand<T, R> message, CancellationToken cancellationToken)
    {
        var alreadyExists = await _requestManager.ExistAsync(message.Id);
        if (alreadyExists)
        {
            return CreateResultForDuplicateRequest();
        }
        else
        {
            await _requestManager.CreateRequestForCommandAsync<T>(message.Id);
            try
            {
                var command = message.Command;
                var commandName = command.GetGenericTypeName();
                var idProperty = string.Empty;
                var commandId = string.Empty;

                switch (command)
                {
                    case CreateOrderCommand createOrderCommand:
                        idProperty = nameof(createOrderCommand.UserId);
                        commandId = createOrderCommand.UserId;
                        break;

                    case CancelOrderCommand cancelOrderCommand:
                        idProperty = nameof(cancelOrderCommand.OrderNumber);
                        commandId = $"{cancelOrderCommand.OrderNumber}";
                        break;

                    case ShipOrderCommand shipOrderCommand:
                        idProperty = nameof(shipOrderCommand.OrderNumber);
                        commandId = $"{shipOrderCommand.OrderNumber}";
                        break;

                    default:
                        idProperty = "Id?";
                        commandId = "n/a";
                        break;
                }

                _logger.LogInformation(
                    "----- Sending command: {CommandName} - {IdProperty}: {CommandId} ({@Command})",
                    commandName,
                    idProperty,
                    commandId,
                    command);

                // Send the embedded business command to mediator so it runs its related CommandHandler
                var result = await _mediator.Send(command, cancellationToken);

                _logger.LogInformation(
                    "----- Command result: {@Result} - {CommandName} - {IdProperty}: {CommandId} ({@Command})",
                    result,
                    commandName,
                    idProperty,
                    commandId,
                    command);

                return result;
            }
            catch
            {
                return default(R);
            }
        }
    }
}
```

Vì IdentifiedCommand hoạt động như một phong bì bao đóng lại business command's, khi  business command cần thực thi bởi vì nó không có một Id lặp lại, sau đó nó nhận inner business command đó và gửi lại cho Mediator, như chạy trong phương thức _mediator.Send(message.Command) ở IdentifiedCommandHandler.cs.

Khi làm điều đó, nó sẽ liên kết và chạy business command handler, trong trường hợp đó [CreateOrderCommandHandler](https://github.com/dotnet-architecture/eShopOnContainers/blob/dev/src/Services/Ordering/Ordering.API/Application/Commands/CreateOrderCommandHandler.cs), đang chạy với transactions đối với Ordering database, như đoạn code dưới đây:

```cs
// CreateOrderCommandHandler.cs
public class CreateOrderCommandHandler
        : IRequestHandler<CreateOrderCommand, bool>
{
    private readonly IOrderRepository _orderRepository;
    private readonly IIdentityService _identityService;
    private readonly IMediator _mediator;
    private readonly IOrderingIntegrationEventService _orderingIntegrationEventService;
    private readonly ILogger<CreateOrderCommandHandler> _logger;

    // Using DI to inject infrastructure persistence Repositories
    public CreateOrderCommandHandler(IMediator mediator,
        IOrderingIntegrationEventService orderingIntegrationEventService,
        IOrderRepository orderRepository,
        IIdentityService identityService,
        ILogger<CreateOrderCommandHandler> logger)
    {
        _orderRepository = orderRepository ?? throw new ArgumentNullException(nameof(orderRepository));
        _identityService = identityService ?? throw new ArgumentNullException(nameof(identityService));
        _mediator = mediator ?? throw new ArgumentNullException(nameof(mediator));
        _orderingIntegrationEventService = orderingIntegrationEventService ?? throw new ArgumentNullException(nameof(orderingIntegrationEventService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task<bool> Handle(CreateOrderCommand message, CancellationToken cancellationToken)
    {
        // Add Integration event to clean the basket
        var orderStartedIntegrationEvent = new OrderStartedIntegrationEvent(message.UserId);
        await _orderingIntegrationEventService.AddAndSaveEventAsync(orderStartedIntegrationEvent);

        // Add/Update the Buyer AggregateRoot
        // DDD patterns comment: Add child entities and value-objects through the Order Aggregate-Root
        // methods and constructor so validations, invariants and business logic
        // make sure that consistency is preserved across the whole aggregate
        var address = new Address(message.Street, message.City, message.State, message.Country, message.ZipCode);
        var order = new Order(message.UserId, message.UserName, address, message.CardTypeId, message.CardNumber, message.CardSecurityNumber, message.CardHolderName, message.CardExpiration);

        foreach (var item in message.OrderItems)
        {
            order.AddOrderItem(item.ProductId, item.ProductName, item.UnitPrice, item.Discount, item.PictureUrl, item.Units);
        }

        _logger.LogInformation("----- Creating Order - Order: {@Order}", order);

        _orderRepository.Add(order);

        return await _orderRepository.UnitOfWork
            .SaveEntitiesAsync(cancellationToken);
    }
}
```

### Đăng ký types sử dụng MediatR

Để MediatR nhận biết được các lớp  command handler  của bạn, bạn cần đăng ký  mediator classes và command handler classes trong IoC container. Về mặc định, về mặc định MediatR sử dụng Autofac là  IoC container, nhưng bạn cũng có thể built-in ASP.NET Core IoC container hoặc bất kỳ container khác hỗ trợ bởi MediatR.

Đoạn code dưới đây cho thấy cách đăng ký Mediator's types và command sử dụng  Autofac modules.

```cs
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        builder.RegisterAssemblyTypes(typeof(IMediator).GetTypeInfo().Assembly)
            .AsImplementedInterfaces();

        // Register all the Command classes (they implement IRequestHandler)
        // in assembly holding the Commands
        builder.RegisterAssemblyTypes(typeof(CreateOrderCommand).GetTypeInfo().Assembly)
                .AsClosedTypesOf(typeof(IRequestHandler<,>));
        // Other types registration
        //...
    }
}
```

Đây là nơi "điều kỳ diệu xảy ra" với MediatR.

Vì mỗi trình command handler triển khai giao diện IRequestHandler<T> chung, khi bạn đăng ký các assemblies  bằng phương thức RegisteredAssemblyTypes, tất cả các loại được đánh dấu là IRequestHandler cũng được đăng ký với Commands của chúng.

Ví dụ:

```cs
public class CreateOrderCommandHandler
  : IRequestHandler<CreateOrderCommand, bool>
{ }
```

handler chỉ đơn giản là một class, nó kế thừa RequestHandler<T>, trong đó T là một command type, và MediatR đảm bảo nó được gọi với chính xác payload (command)

### Áp dụng cross-cutting concerns khi processing commands với Behaviors trong MediatR

Còn một điều nữa, có thể áp dụng cross-cutting concerns thông qua mediator pipeline. Bạn cũng có thể xem ở cuối mã mô-đun đăng ký Autofac cách nó đăng ký một loại behavior , cụ thể là lớp LoggingBehavior tùy chỉnh và lớp ValidatorBehavior. Nhưng bạn cũng có thể thêm các behaviors tùy chỉnh khác.

```cs
public class MediatorModule : Autofac.Module
{
    protected override void Load(ContainerBuilder builder)
    {
        builder.RegisterAssemblyTypes(typeof(IMediator).GetTypeInfo().Assembly)
            .AsImplementedInterfaces();

        // Register all the Command classes (they implement IRequestHandler)
        // in assembly holding the Commands
        builder.RegisterAssemblyTypes(
                              typeof(CreateOrderCommand).GetTypeInfo().Assembly).
                                   AsClosedTypesOf(typeof(IRequestHandler<,>));
        // Other types registration
        //...
        builder.RegisterGeneric(typeof(LoggingBehavior<,>)).
                                                   As(typeof(IPipelineBehavior<,>));
        builder.RegisterGeneric(typeof(ValidatorBehavior<,>)).
                                                   As(typeof(IPipelineBehavior<,>));
    }
}
```

Lớp LoggingBehavior đó có thể được triển khai dưới dạng đoạn mã sau, ghi lại thông tin về trình xử lý lệnh đang được thực thi và liệu nó có thành công hay không.

```cs
public class LoggingBehavior<TRequest, TResponse>
         : IPipelineBehavior<TRequest, TResponse>
{
    private readonly ILogger<LoggingBehavior<TRequest, TResponse>> _logger;
    public LoggingBehavior(ILogger<LoggingBehavior<TRequest, TResponse>> logger) =>
                                                                  _logger = logger;

    public async Task<TResponse> Handle(TRequest request,
                                        RequestHandlerDelegate<TResponse> next)
    {
        _logger.LogInformation($"Handling {typeof(TRequest).Name}");
        var response = await next();
        _logger.LogInformation($"Handled {typeof(TResponse).Name}");
        return response;
    }
}
```

Chỉ bằng cách triển khai lớp behavior  này và bằng cách đăng ký nó trong pipeline  (trong MediatorModule ở trên), tất cả các commands  được xử lý thông qua MediatR sẽ ghi thông tin về quá trình thực thi.

eShopOnContainers cũng áp dụng behavior thứ hai cho các hoạt động xác thực cơ bản, lớp ValidatorBehavior dựa trên thư viện FluentValidation, như minh họa trong đoạn mã sau:

```cs
public class ValidatorBehavior<TRequest, TResponse>
         : IPipelineBehavior<TRequest, TResponse>
{
    private readonly IValidator<TRequest>[] _validators;
    public ValidatorBehavior(IValidator<TRequest>[] validators) =>
                                                         _validators = validators;

    public async Task<TResponse> Handle(TRequest request,
                                        RequestHandlerDelegate<TResponse> next)
    {
        var failures = _validators
            .Select(v => v.Validate(request))
            .SelectMany(result => result.Errors)
            .Where(error => error != null)
            .ToList();

        if (failures.Any())
        {
            throw new OrderingDomainException(
                $"Command Validation Errors for type {typeof(TRequest).Name}",
                        new ValidationException("Validation exception", failures));
        }

        var response = await next();
        return response;
    }
}
```

Ở đây, behavior  sẽ đưa ra một ngoại lệ nếu việc xác thực không thành công, nhưng bạn cũng có thể trả về một đối tượng kết quả, chứa kết quả lệnh nếu nó thành công hoặc các thông báo xác thực trong trường hợp không thành công.

Sau đó, dựa trên thư viện FluentValidation, bạn sẽ tạo xác thực cho dữ liệu được truyền bằng CreateOrderCommand, như trong đoạn mã sau:

```cs
public class CreateOrderCommandValidator : AbstractValidator<CreateOrderCommand>
{
    public CreateOrderCommandValidator()
    {
        RuleFor(command => command.City).NotEmpty();
        RuleFor(command => command.Street).NotEmpty();
        RuleFor(command => command.State).NotEmpty();
        RuleFor(command => command.Country).NotEmpty();
        RuleFor(command => command.ZipCode).NotEmpty();
        RuleFor(command => command.CardNumber).NotEmpty().Length(12, 19);
        RuleFor(command => command.CardHolderName).NotEmpty();
        RuleFor(command => command.CardExpiration).NotEmpty().Must(BeValidExpirationDate).WithMessage("Please specify a valid card expiration date");
        RuleFor(command => command.CardSecurityNumber).NotEmpty().Length(3);
        RuleFor(command => command.CardTypeId).NotEmpty();
        RuleFor(command => command.OrderItems).Must(ContainOrderItems).WithMessage("No order items found");
    }

    private bool BeValidExpirationDate(DateTime dateTime)
    {
        return dateTime >= DateTime.UtcNow;
    }

    private bool ContainOrderItems(IEnumerable<OrderItemDTO> orderItems)
    {
        return orderItems.Any();
    }
}
```


Bạn có thể tạo validations bổ sung. Đây là một cách rất rõ ràng và tinh tế để triển khai validations command  của bạn.

Theo cách tương tự, bạn có thể triển khai các behavior khác cho các khía cạnh bổ sung hoặc các mối quan tâm xuyên suốt mà bạn muốn áp dụng cho các lệnh khi xử lý chúng.

