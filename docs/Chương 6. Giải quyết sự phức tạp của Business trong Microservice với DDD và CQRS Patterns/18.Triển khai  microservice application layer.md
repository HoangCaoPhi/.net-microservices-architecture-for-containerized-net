### Sử dụng DI để inject infrastructure objects vào application layer

Như đề cập trước đó, application layer có thể triển khai như một phần của assembly bạn xây dựng, như là Web API project hoặc một MVC web app project. Trong trường hợp một microservice được xây dựng bằng ASP.NET Core, application layer sẽ thường sẽ sử dụng Web API libaray.

Nếu bạn muốn tách những gì đến từ ASP.NET Core (infrastructure cộng với controllers của bạn) ra khỏi application layer code, bạn có thể đặt application layer ở class libary riêng biệt, nhưng nó là tùy chọn.

Ví dụ, application layer code của ordering microservice trực tiếp được triển khai là một phần của Ordering.API (một ASP.NET Core Web API project) như hình 7-23:

![image.png](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/media/microservice-application-layer-implementation-web-api/ordering-api-microservice.png)

ASP.NET Core bao gồm một [built-in IoC container ](https://learn.microsoft.com/en-us/aspnet/core/fundamentals/dependency-injection?view=aspnetcore-8.0) (được biểu thị bằng interface IServiceProvider) hỗ trợ constructor injection theo mặc định và ASP.NET cung cấp một số service nhất định thông qua DI.

ASP.NET Core sử dụng thuật ngữ service cho bất kỳ loại nào bạn đăng ký sẽ được đưa vào thông qua DI. Bạn cấu hình các built-in container's services trong ứng dụng của bạn ở file Program.cs. Các dependencies của bạn sẽ được triển khai và đăng ký trong IoC container.

Thông thường, bạn muốn inject dependencies để implement infrastructure objects. Một dependency điển hình cho việc inject là một repository. Nhưng bạn có thể inject bất kỳ infrastructure dependency khác mà bạn có. Để thực hiện nó đơn giản, bạn có thể trực tiếp inject Unit of Work pattern của bạn (EF DbContext object) bởi vì DBContext cũng được triển khai ở infrastructure persistence objects của bạn.

Trong ví dụ sau, bạn có thể thấy cách .NET đưa các đối tượng kho lưu trữ cần thiết thông qua hàm tạo. Lớp này là một command handler, sẽ được đề cập trong phần tiếp theo.

```cs
public class CreateOrderCommandHandler
        : IRequestHandler<CreateOrderCommand, bool>
{
    private readonly IOrderRepository _orderRepository;
    private readonly IIdentityService _identityService;
    private readonly IMediator _mediator;
    private readonly IOrderingIntegrationEventService _orderingIntegrationEventService;
    private readonly ILogger<CreateOrderCommandHandler> _logger;

    // Using DI to inject infrastructure persistence Repositories
    public CreateOrderCommandHandler(IMediator mediator,
        IOrderingIntegrationEventService orderingIntegrationEventService,
        IOrderRepository orderRepository,
        IIdentityService identityService,
        ILogger<CreateOrderCommandHandler> logger)
    {
        _orderRepository = orderRepository ?? throw new ArgumentNullException(nameof(orderRepository));
        _identityService = identityService ?? throw new ArgumentNullException(nameof(identityService));
        _mediator = mediator ?? throw new ArgumentNullException(nameof(mediator));
        _orderingIntegrationEventService = orderingIntegrationEventService ?? throw new ArgumentNullException(nameof(orderingIntegrationEventService));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    public async Task<bool> Handle(CreateOrderCommand message, CancellationToken cancellationToken)
    {
        // Add Integration event to clean the basket
        var orderStartedIntegrationEvent = new OrderStartedIntegrationEvent(message.UserId);
        await _orderingIntegrationEventService.AddAndSaveEventAsync(orderStartedIntegrationEvent);

        // Add/Update the Buyer AggregateRoot
        // DDD patterns comment: Add child entities and value-objects through the Order Aggregate-Root
        // methods and constructor so validations, invariants and business logic
        // make sure that consistency is preserved across the whole aggregate
        var address = new Address(message.Street, message.City, message.State, message.Country, message.ZipCode);
        var order = new Order(message.UserId, message.UserName, address, message.CardTypeId, message.CardNumber, message.CardSecurityNumber, message.CardHolderName, message.CardExpiration);

        foreach (var item in message.OrderItems)
        {
            order.AddOrderItem(item.ProductId, item.ProductName, item.UnitPrice, item.Discount, item.PictureUrl, item.Units);
        }

        _logger.LogInformation("----- Creating Order - Order: {@Order}", order);

        _orderRepository.Add(order);

        return await _orderRepository.UnitOfWork
            .SaveEntitiesAsync(cancellationToken);
    }
}
```

Lớp này sử dụng để njected repositories thực thi transaction và persist những state changes. Không quan trọng lớp đó có phải là command handler hay không, một ASP.NET Core Web API controller method hoặc một [ DDD Application Service](https://lostechies.com/jimmybogard/2008/08/21/services-in-domain-driven-design/) cuối cùng nó là một lớp đơn giản sử dụng repositories, domain entities và phối hợp các ứng dụng khác theo các tương tự một command handler. Dependency Injection làm việc theo cách tương tự tất cả các lớp đã được đề cập, như trong ví dụ sử dụng DI dựa trên hàm tạo.

### Đăng ký dependency implementation types với interfaces hoặc abstractions

Trước khi bạn sử dụng objects injected thông qua constructors, bạn cần biết đăng ký interface và lớp implement của nó được đăng ký ở đâu. (Giống như DI dựa trên hàm tạo, như được hiển thị trước đó).

### Sử dụng built-in IoC container cung cấp bởi ASP.NET Core

Khi bạn sử dụng built-in IoC container cung cấp bởi ASP.NET Core, bạn đăng ký types bạn muốn inject ở trong file Program.cs như đoạn code sau:

```cs
// Register out-of-the-box framework services.
builder.Services.AddDbContext<CatalogContext>(c =>
    c.UseSqlServer(Configuration["ConnectionString"]),
    ServiceLifetime.Scoped);

builder.Services.AddMvc();
// Register custom application dependencies.
builder.Services.AddScoped<IMyCustomRepository, MyCustomSQLRepository>();
```

Pattern phổ biến khi đăng ký types trong một IoC container là đăng ký một cặp types là một interface và một lớp implement liên quan đến nó. Sau đó, bạn yêu cầu một đối tượng từ IoC container thông qua bất kỳ constructor nào, bạn yêu cầu một đối tượng của một interface nhất định. Ví dụ, trong ví dụ trước bất kỳ hàm tạo nào có một dependency trên IMyCustomRepository, IoC container sẽ inject một instance của lớp MyCustomSQLServerRepository.

### Sử dụng Scrutor library để đăng ký automatic types

Khi sử dụng DI trong .NET, bạn có thể muốn quét một assembly và tự động đăng ký các loại của nó theo convention.

Tính năng này hiện không có sẵn trong ASP.NET Core. Tuy nhiên, bạn có thể sử dụng thư viện Scrutor cho việc đó. Cách tiếp cận này thuận tiện khi bạn có hàng tá loại cần được đăng ký trong vùng chứa IoC của mình.

Tài nguyên bổ sung

Matthew King. Registering services with Scrutor
https://www.mking.net/blog/registering-services-with-scrutor

Kristian Hellang. Scrutor. GitHub repo.
https://github.com/khellang/Scrutor

### Sử dụng Autofac là một IoC container

Bạn cũng có thể sử dụng thêm IoC containers và cài chúng vào trong ASP.NET Core pipeline, như trong ordering microservice, chúng tôi sử dụng Autofac. Sử dụng Autofac với ASP.NET Core cung cấp sự kiểm soát nâng cao đối với dependency injection và cho phép bạn tách logic đăng ký vào nhiều tệp hoặc thư viện bằng cách sử dụng các module. Cách tiếp cận module này giúp tổ chức và bảo trì các phụ thuộc của ứng dụng dễ dàng hơn, đặc biệt khi ứng dụng ngày càng phức tạp.

Ví dụ: sau đây là mô-đun ứng dụng Autofac cho dự án API Web Ordering.API với các loại bạn sẽ muốn đưa vào.

```cs
public class ApplicationModule : Autofac.Module
{
    public string QueriesConnectionString { get; }
    public ApplicationModule(string qconstr)
    {
        QueriesConnectionString = qconstr;
    }

    protected override void Load(ContainerBuilder builder)
    {
        builder.Register(c => new OrderQueries(QueriesConnectionString))
            .As<IOrderQueries>()
            .InstancePerLifetimeScope();
        builder.RegisterType<BuyerRepository>()
            .As<IBuyerRepository>()
            .InstancePerLifetimeScope();
        builder.RegisterType<OrderRepository>()
            .As<IOrderRepository>()
            .InstancePerLifetimeScope();
        builder.RegisterType<RequestManager>()
            .As<IRequestManager>()
            .InstancePerLifetimeScope();
   }
}
```

Autofac còn có tính năng scan assenblíe và đăng ký các types theo quy ước tên.

Quá trình đăng ký và các khái niệm rất giống với cách bạn có thể đăng ký các types với IoC container của ASP.NET Core tích hợp sẵn, nhưng cú pháp khi sử dụng Autofac hơi khác một chút.

Trong mã ví dụ, IOrderRepository trừu tượng được đăng ký cùng với lớp triển khai OrderRepository. Điều này có nghĩa là bất cứ khi nào một hàm tạo khai báo một phần phụ thuộc thông qua interface IOrderRepository, bộ chứa IoC container inject một instance của lớp OrderRepository.

Tài nguyên bổ sung

Introduction to Dependency Injection in ASP.NET Core
https://learn.microsoft.com/aspnet/core/fundamentals/dependency-injection

Autofac. Official documentation.
https://docs.autofac.org/en/latest/

Comparing ASP.NET Core IoC container service lifetimes with Autofac IoC container instance scopes - Cesar de la Torre.
https://devblogs.microsoft.com/cesardelatorre/comparing-asp-net-core-ioc-service-life-times-and-autofac-ioc-instance-scopes/

### Triển khai Command và ommand Handler patterns

Trong ví dụ về DI-through-constructor được trình bày ở phần trước, bộ chứa IoC đang injecting repositories thông qua một hàm tạo trong một lớp. Nhưng chính xác là chúng được injected vào đâu? Trong một API Web đơn giản (ví dụ: microservice catalog trong eShopOnContainers), bạn inject chúng vào MVC controllers' level, trong controller constructor, như một phần của request pipeline của ASP.NET Core. Trong đoạn code của phần đầu tiên (lớp [ CreateOrderCommandHandler](https://github.com/dotnet-architecture/eShopOnContainers/blob/main/src/Services/Ordering/Ordering.API/Application/Commands/CreateOrderCommandHandler.cs) từ Ordering.API service trong eShopOnContainers), việc inject thông qua constructor là một phần của command handler. Chúng ta sẽ giải thích command handler là gì và tại sao lại sử dụng nó.

Command pattern là một pattern về bản chất liên quan đến CQRS pattern đã giới thiệu ở trước đó. CQRS có hai sides. Đầu tiên là khu vực cho queries, sử dụng queries đơn giản với Dapper micro ORM đã giải thích ở trước đó. Thứ hai là commands, là điểm bắt đầu cho các transactions, và là kênh đầu vào từ bên ngoài service.

Như trong hình 7-24, pattern dựa trên việc chấp nhận các commands từ client-side, xử lý chúng dựa trên domain model rules, và cuối cùng persisting states với transactions.

![image.png](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/media/microservice-application-layer-implementation-web-api/high-level-writes-side.png)

Hình 7-24 cho thấy ứng dụng UI gửi Command thông qua API tới CommandHandler, Command này phụ thuộc vào Domain model và Infrastructure để cập nhật cơ sở dữ liệu.

### Command class

Một command là một yêu cầu đến hệ thống thực hiện một hành động thay đổi trạng thái của hệ thống. Đây là những yêu cầu cụ thể, có tính chất mệnh lệnh và chỉ nên được xử lý một lần.

Vì commands có tính chất mệnh lệnh, nên chúng thông thường có tên với một động từ ở thể mệnh lệnh (ví dụ, "create" hoặc "update"), và chúng có thể bao gồm aggregate type, như là CreateOrderCommand. Không giống event, nó không phải là một hành động đã xảy ra trong quá khứ, nó chỉ là một request và có thể bị refused.

Commands có thể xuất phát từ hai nguồn chính trong một hệ thống phần mềm:

- Giao diện người dùng (UI):
  Commands có thể được khởi tạo từ UI khi người dùng thực hiện một hành động. Ví dụ, khi người dùng nhấn nút "Đặt hàng" trên trang web, một command sẽ được tạo ra để yêu cầu hệ thống tạo đơn hàng mới.
- Process Manager:
  Commands cũng có thể được tạo ra từ một process manager (còn gọi là saga). Process manager là một thành phần điều phối các hành động giữa các aggregates khác nhau. Khi process manager yêu cầu một aggregate thực hiện một hành động cụ thể, nó sẽ tạo ra và gửi command đó.

Một đặc điểm quan trọng của command là nó chỉ được xử lý một lần bởi một người nhận. Điều này là do command là một hành động hoặc giao dịch đơn lẻ mà bạn muốn thực hiện trong ứng dụng. Ví dụ: cùng một lệnh tạo đơn hàng không được xử lý nhiều lần. Đây là sự khác biệt quan trọng giữa command và event. Các events có thể được xử lý nhiều lần vì nhiều hệ thống hoặc vi dịch vụ có thể quan tâm đến event này.

Ngoài ra, điều quan trọng là một command chỉ được xử lý một lần trong trường hợp lệnh đó idempotent. Một command là idempotent nếu nó có thể được thực thi nhiều lần mà không thay đổi kết quả, do tính chất của command hoặc do cách hệ thống xử lý command.

Đó là một cách thực hành tốt để làm cho các commands và update của bạn trở nên idempotent khi nó có ý nghĩa theo các domain's business rules và invariants trong miền của bạn. Ví dụ: để sử dụng cùng một ví dụ, nếu vì bất kỳ lý do nào (retry logic, hacking, etc.), cùng một CreateOrder command đến hệ thống của bạn nhiều lần, bạn phải có thể xác định lệnh đó và đảm bảo rằng bạn không tạo nhiều đơn hàng. Để làm như vậy, bạn cần đính kèm một số loại nhận dạng trong các hoạt động và xác định xem command hoặc update đã được xử lý chưa.

Bạn gửi command đến một người nhận; bạn không publish một command. Publishing dành cho events (một điều gì đó đã xảy ra và những người nhận là những người có thể quan tâm đến events đó). Trong trường hợp events, publisher không cần bận tâm về receivers nào nhận nó và họ làm gì với chúng. Nhưng domain hoặc integration events thì là một câu chuyện khác đã được giới thiệu ở phần trước.

Một command được triển khai bằng một lớp chứa data fields hoặc collections với tất cả thông tin cần để thực thi một command. Một command là một Data Transfer Object (DTO) đặc biệt, được sử dụng cụ thể để yêu cầu thay đổi hoặc giao dịch. Bản thân command dựa trên những thông tin cần thiết để xử lý command, và không làm gì nhiều hơn.

Ví dụ sau đây cho thấy lớp CreateOrderCommand đơn giản. Đây là một immutable command được sử dụng trong ordering microservice trong eShopOnContainers.

```cs
// DDD and CQRS patterns comment: Note that it is recommended to implement immutable Commands
// In this case, its immutability is achieved by having all the setters as private
// plus only being able to update the data just once, when creating the object through its constructor.
// References on Immutable Commands:
// http://cqrs.nu/Faq
// https://docs.spine3.org/motivation/immutability.html
// http://blog.gauffin.org/2012/06/griffin-container-introducing-command-support/
// https://learn.microsoft.com/dotnet/csharp/programming-guide/classes-and-structs/how-to-implement-a-lightweight-class-with-auto-implemented-properties

[DataContract]
public class CreateOrderCommand
    : IRequest<bool>
{
    [DataMember]
    private readonly List<OrderItemDTO> _orderItems;

    [DataMember]
    public string UserId { get; private set; }

    [DataMember]
    public string UserName { get; private set; }

    [DataMember]
    public string City { get; private set; }

    [DataMember]
    public string Street { get; private set; }

    [DataMember]
    public string State { get; private set; }

    [DataMember]
    public string Country { get; private set; }

    [DataMember]
    public string ZipCode { get; private set; }

    [DataMember]
    public string CardNumber { get; private set; }

    [DataMember]
    public string CardHolderName { get; private set; }

    [DataMember]
    public DateTime CardExpiration { get; private set; }

    [DataMember]
    public string CardSecurityNumber { get; private set; }

    [DataMember]
    public int CardTypeId { get; private set; }

    [DataMember]
    public IEnumerable<OrderItemDTO> OrderItems => _orderItems;

    public CreateOrderCommand()
    {
        _orderItems = new List<OrderItemDTO>();
    }

    public CreateOrderCommand(List<BasketItem> basketItems, string userId, string userName, string city, string street, string state, string country, string zipcode,
        string cardNumber, string cardHolderName, DateTime cardExpiration,
        string cardSecurityNumber, int cardTypeId) : this()
    {
        _orderItems = basketItems.ToOrderItemsDTO().ToList();
        UserId = userId;
        UserName = userName;
        City = city;
        Street = street;
        State = state;
        Country = country;
        ZipCode = zipcode;
        CardNumber = cardNumber;
        CardHolderName = cardHolderName;
        CardExpiration = cardExpiration;
        CardSecurityNumber = cardSecurityNumber;
        CardTypeId = cardTypeId;
        CardExpiration = cardExpiration;
    }


    public class OrderItemDTO
    {
        public int ProductId { get; set; }

        public string ProductName { get; set; }

        public decimal UnitPrice { get; set; }

        public decimal Discount { get; set; }

        public int Units { get; set; }

        public string PictureUrl { get; set; }
    }
}
```

Về cơ bản, command class chứa tất cả data bạn cần để thực hiện một business transaction bằng cách sử dụng domain model objects. Vì vậy, commands đơn giản là một data structures chứa read-only data, và không có behavior. Command's name cho biết mục đích của nó. Trong nhiều ngôn ngữ như C#, commands được biểu diễn dưới dạng các lớp, nhưng chúng không phải là các lớp thực sự theo nghĩa hướng đối tượng.

Thêm một đặc điểm nữa là, commands là immutable, bởi vì mục đích sử dụng dự kiến là chúng được domain model xử lý trực tiếp. Chúng không cần phải thay đổi trong suốt thời gian tồn tại dự kiến của chúng. Trong lớp C#, immutability có thể đạt được bằng cách không có bất kỳ setters hoặc phương thức nào khác thay đổi trạng thái bên trong.

Hãy nhớ rằng nếu bạn dự định hoặc mong đợi các lệnh sẽ trải qua quá trình serializing/deserializing thì các thuộc tính phải có một private setter và thuộc tính [DataMember] (hoặc [JsonProperty]). Nếu không, deserializer sẽ không thể xây dựng lại đối tượng tại đích với các giá trị được yêu cầu. Bạn cũng có thể sử dụng các thuộc tính read-only nếu lớp có một hàm tạo với các tham số cho tất cả các thuộc tính, với quy ước đặt tên CamelCase thông thường và chú thích hàm tạo đó là [JsonConstructor]. Tuy nhiên, tùy chọn này yêu cầu nhiều mã hơn.

Ví dụ: lớp command để tạo đơn hàng có thể tương tự về mặt dữ liệu với đơn hàng bạn muốn tạo, nhưng có thể bạn không cần các thuộc tính giống nhau. Ví dụ: CreateOrderCommand không có ID đơn hàng vì đơn hàng chưa được tạo.

Nhiều lớp command có thể đơn giản, chỉ yêu cầu một vài trường về một số trạng thái cần thay đổi. Trường hợp đó xảy ra nếu bạn chỉ thay đổi trạng thái của đơn hàng từ "đang xử lý" thành "đã thanh toán" hoặc "đã giao hàng" bằng cách sử dụng command tương tự như sau:

```cs
[DataContract]
public class UpdateOrderStatusCommand
    :IRequest<bool>
{
    [DataMember]
    public string Status { get; private set; }

    [DataMember]
    public string OrderId { get; private set; }

    [DataMember]
    public string BuyerIdentityGuid { get; private set; }
}
```

Một số nhà phát triển tách biệt các đối tượng yêu cầu giao diện người dùng khỏi DTO lệnh của họ, nhưng đó chỉ là vấn đề ưu tiên. Đó là một sự tách biệt tẻ nhạt, không có nhiều giá trị bổ sung và các đối tượng như có hình dạng giống hệt nhau.

Ví dụ: trong eShopOnContainers, một số commands đến trực tiếp từ phía máy khách.

### Command handler class


