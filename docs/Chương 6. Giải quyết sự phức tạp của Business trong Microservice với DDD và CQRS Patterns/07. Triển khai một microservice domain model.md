Bản dịch từ [nguồn](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/net-core-microservice-domain-model)

Trong phần trước, các nguyên tắc thiết kế cơ bản và các patterns để thiết kế một domain model đã được giải thích. Bây giờ đã đến lúc chúng ta triển khai domain model bằng cách sử dụng .NET và EFCore. Domain model của bạn sẽ chỉ đơn giản là mã của bạn. Nó sẽ chỉ có model mà EF Core yêu cầu, nhưng nó không phụ thuộc một chút nào đến EF. Bạn không nên có bất kỳ phụ thuộc hoặc tham chiếu bắt buộc nào đến EF Core hoặc bất kỳ ORM nào khác ở trong Domain Model.

### Cấu trúc Domain model trong dự án

Tổ chức thư mục trong eShopOnContainers thê hiện mô hình DDD model trong ứng dụng. Tuy nhiên, việc tùy chỉnh cấu trúc thư mục để phù hợp hơn với các yêu cầu và thiết kế cụ thể của ứng dụng của bạn là hoàn toàn hợp lý và có thể giúp truyền tải rõ ràng hơn các lựa chọn thiết kế đã được thực hiện. Như hình 7-10, trong ordering domain model có hai aggregates, là order aggregate và buyer aggregate. Mỗi một aggreate là một nhóm domain entities và value objects, tuy nhiên bạn cũng có thể tạo một aggregate bao gồm duy nhất một domain entity (aggregate root hoặc root entity).

![image.png](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/media/net-core-microservice-domain-model/ordering-microservice-container.png)

Hình 7-10, cấu trúc Domain model cho ordering microservice trong eShopOnContainers

Thêm vào đó, domain model layer còn bao gồm repository contracts (interfaces) là các yêu cầu đến infrastructure của domain model của bạn. Nói cách khác, interface này thể hiện những phương thức nào mà infrastructure layer phải triển khai. Điều quan trọng là việc triển khai những repositories phải đặt ở ngoài domain model layer, đặt nó ở trong infrastructure layer, vì vậy domain model layer không bị "contaminated" bởi API hoặc lớp từ infrastructure technologies như Entity Framework.

Bạn có thể thấy thư mục [SeedWork](https://martinfowler.com/bliki/Seedwork.html) chứa custom base classes, bạn có thể sử dụng làm base cho domain entities và value objects của bạn, vì vậy bạn không có những mã dư thừa, lặp đi lặp lại trong mỗi domain's object class.

### Cấu trúc aggregates trong dự án

Một aggreate đề cập đến một cụm các domain objects được nhóm lại với nhau để phù hợp cho tính nhất quán của transactional. Các đối tượng đó có thể là intances của entities (một trong đó đó có thể là aggreate root hoặc root entity) cộng với bất kỳ value objects nào.

Đảm bảo tính nhất quán của Transactional có nghĩa là aggregate đảm bảo tính nhất quán và cập nhật mới nhất (đảm bảo rằng không có thành phần nào bị bỏ sót hoặc lỗi thời) khi kết thúc một business action. Ví dụ, order aggregate từ eShopOnContainers ordering microservice domain model là bao gồm những gì hiển thị trong hình 7.11:

![image.png](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/media/net-core-microservice-domain-model/vs-solution-explorer-order-aggregate.png)

Triển khai domain entities là một POCO classes

Bạn triển khai một domain model trong .NET bằng cách tạo POCO classes để triển khai domain entities. Trong ví dụ dưới đây, lớp Order được định nghĩa là một entity và cũng là một aggregate root. Bởi vì Order kế thừa từ lớp Entity base, nó có thể tái sử dụng đoạn code chung liên quan đến các entities. Lưu ý rằng, các lớp base và các interfaces bạn định nghĩa bởi bạn ở trong domain model, vì vậy nó là code của bạn, không phải là infrastructure code từ ORM như EF.

```csharp
// COMPATIBLE WITH ENTITY FRAMEWORK CORE 5.0
// Entity is a custom base class with the ID
public class Order : Entity, IAggregateRoot
{
    private DateTime _orderDate;
    public Address Address { get; private set; }
    private int? _buyerId;

    public OrderStatus OrderStatus { get; private set; }
    private int _orderStatusId;

    private string _description;
    private int? _paymentMethodId;

    private readonly List<OrderItem> _orderItems;
    public IReadOnlyCollection<OrderItem> OrderItems => _orderItems;

    public Order(string userId, Address address, int cardTypeId, string cardNumber, string cardSecurityNumber,
            string cardHolderName, DateTime cardExpiration, int? buyerId = null, int? paymentMethodId = null)
    {
        _orderItems = new List<OrderItem>();
        _buyerId = buyerId;
        _paymentMethodId = paymentMethodId;
        _orderStatusId = OrderStatus.Submitted.Id;
        _orderDate = DateTime.UtcNow;
        Address = address;

        // ...Additional code ...
    }

    public void AddOrderItem(int productId, string productName,
                            decimal unitPrice, decimal discount,
                            string pictureUrl, int units = 1)
    {
        //...
        // Domain rules/logic for adding the OrderItem to the order
        // ...

        var orderItem = new OrderItem(productId, productName, unitPrice, discount, pictureUrl, units);

        _orderItems.Add(orderItem);

    }
    // ...
    // Additional methods with domain rules/logic related to the Order aggregate
    // ...
}
```
Điểm quan trọng cần lưu ý là một domain entity triển khai theo POCO class. Nó không có bất kỳ phụ thuộc vào Entity Framework Core hoặc bất kỳ infrastructure framework nào khác. Đây là cách triển khai nên được sử dụng trong DDD, chỉ duy nhất code C# được triển khai trong domain model, không phụ thuộc vào bất kỳ bên thứ 3 nào khác.

Ngoài ra, các lớp còn được decorated với một interface là IAggregateRoot, nó là empty interface, thi thoảng được gọi là marker interface, được sử dụng chỉ để chỉ ra rằng domain entity này là một aggregate root.

Một marker interface đôi khi được coi là một anti-pattern, tuy nhiên, đó cũng là một cách rõ ràng đến đánh dấu một lớp, đặc biệt khi interface có thể phát triển. Một attribute có thể là một lựa chọn khác cho việc marker, nhưng nó nhanh hơn khi nhìn thấy base class (Entity) tiếp theo là IAggregate interface ở ngay bên cạnh tên lớp, thay vì đặt Aggregate attribute ở trên tên lớp. Nó là vấn đề về sở thích, trong bất kỳ trường hợp nào.



