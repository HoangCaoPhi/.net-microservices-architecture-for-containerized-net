Mục tiêu của bạn là tạo domain model duy nhất và duy trì tính cohesive cho mỗi business microservice hoặc Bounded Context (BC). Ghi nhớ điều này, tuy nhiên, một BC hoặc business microservice thi thoảng có thể bao gồm một vài physical services chia sẻ một domain model (Ví dụ Order Processing Service, Order History Service đều nằm trong Bounded Context Quản Lý Đơn Hàng nhưng chia sẻ chung một domain model để đảm bảo tính nhất quán). Domain model phải nắm bắt các quy tắc, behavior, business language và các ràng buộc trong một Bounded Context hoặc business microservice mà nó đại diện.

### Domain Entity pattern

Entities đại diện cho domain objects và được xác định chủ yếu dựa vào tính identity, tính liên tục và bền vững của chúng theo thời gian không chỉ bởi các thuộc tính của chúng. Eric Evans nói rằng "an object primarily defined by its identity is called an Entity" (một đối tượng được xác định bởi tính identity của chúng được gọi là một Entity). Entities rất quan trọng trong  domain model, vì chúng là cơ sở cho một model. Vì vậy, bạn nên identify và thiết kế chúng một cách cẩn thận.

_Một entity's identity có thể được sử dụng ở nhiều microservices hoặc Bounded Contexts._

Trong nhiều Bounded Contexts hoặc microservices khác nhau, một domain entity có thể được nhận diện bởi cùng một giá trị ID. Ví dụ, một khách hàng có thể có cùng một CustomerId trong hệ thống đặt hàng và hệ thống quản lý khách hàng. Mặc dù giá trị ID là giống nhau, domain entity trong các Bounded Contexts khác nhau không nhất thiết phải có cùng các thuộc tính và logic. Mỗi Bounded Context chỉ cần quan tâm đến các thuộc tính và hành vi phù hợp với nhu cầu của nó. Các domain entity trong mỗi Bounded Context sẽ chỉ bao gồm các thuộc tính và hành vi cần thiết cho nghiệp vụ của Bounded Context đó. 

Ví dụ, buyer entity có hầu hết những thuộc tính của một người đã được định nghĩa trong user entity trong profile hoặc identity microservice, bao gồm cả định danh (identity) của nó. Nhưng buyer entity ở trong ordering microservice lại chỉ có một vài thuộc tính, bởi vì nó chỉ chứa thông tin người mua liên quan đến quá trình đặt hàng. Ngữ cảnh của từng microservice hoặc BC sẽ tác động đến domain model của nó.

_Domain entities không chỉ đơn thuần là các đối tượng lưu trữ dữ liệu. Chúng còn phải chứa đựng các behavior liên quan đến nghiệp vụ._

Một domain entity trong DDD không chỉ đơn giản là các đối tượng dữ liệu được lưu trữ trong bộ nhớ. Thay vào đó, chúng còn phải bao gồm domain logic hoặc behavior liên quan đến dữ liệu của chúng. Ví dụ, trong một order entity bạn phải có business logic và các thao tác được triển khai dưới dạng phương thức như thêm vào order item, data validation và tính tổng đơn hàng. Các phương thức trong entity phải đảm bảo rằng nó vẫn mang tính invariants và các quy tắc của entity thay vì để nó trải dài khắp application layer.

Hình 7-8 hiển thị một domain entity triển khai không chỉ thuộc tính của data mà còn có phương thức liên quan đến domain logic

![image.png](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/media/microservice-domain-model/domain-entity-pattern.png)


Hình 7-8. Ví dụ về thiết kế domain entity gồm thuộc tính và các behavior

Domain model entity thực hiện các behaviors thông qua các phương thức, vì vậy nó không phải là một "anemic" model. Tất nhiên, đôi khi bạn có thể có các entity không có bất kì phần logic nào ở trong lớp đó. Nó có thể xảy ra trong child entities trong một aggregate, child entity không có bất kỳ logic đặc biệt nào bởi vì hầu hết logic được định nghĩa ở trong aggregate root. Nếu một microservice phức tạp có logic được triển khai ở trong một lớp service thay vì domain entities, thì bạn có thể rơi vào mô hình "anemic", phần sau sẽ giải thích vấn đề này.

### Rich domain model  và anemic domain model

Trong bài viết [AnemicDomainModel](https://martinfowler.com/bliki/AnemicDomainModel.html) Martin Fowler mô tả một anemic domain model như sau:

Anemic Domain Model ban đầu trông giống như một domain models thực thụ, nó là một đối tượng, nhiều thuộc tính được đặt trong nó, những đối tượng được kết nối với nhau theo các mối quan hệ và cấu trúc phúc tạp. Nhưng khi xem xét kỹ về behavior, bạn có thể nhận ra là không có một behavior nào ở trong đối tượng này, nó chỉ là các bộ dữ liệu (data containers), chứa các trường dữ liệu và các phương thức truy cập và thiết lập dữ liệu (getters và setters). 

Vì vậy, khi bạn sử dụng Anemic Domain Model, những data models đó sẽ được sử dụng bởi một tập hợp các services (theo truyền thống được đặt là business layer), sẽ nắm bắt tất cả các domain hoặc business logic. Business layer năm trên data model và sử dụng data model như là dữ liệu.

Anemic domain model được thiết kế theo phong cách procedural. Anemic entity objects không thực chất là objects bởi vì chúng thiếu đi behavior (methods). Chúng chỉ chứa duy nhất data properties nên chúng không phải là thiết kế hướng đối tượng. Bằng cách đặt tất cả behavior ở service objects (như business layer), dẫn đến mã nguồn của bạn đối mặt với [spaghetti code](https://en.wikipedia.org/wiki/Spaghetti_code) hoặc [transaction scripts](https://martinfowler.com/eaaCatalog/transactionScript.html), và vì vậy bạn mất đi lợi ích mà domain model cung cấp.

Dù vậy, nếu microservice của bạn hoặc Bounded Context rất đơn giản (1 CRUD service), anemic domain model ở dạng entity objects chỉ bao gồm data properties có thể đủ tốt, và nó không đáng phải triển khai DDD patterns phức tạp. Trong trường hợp này, nó chỉ đơn giản là một persistence model, bởi vì bạn đã cố tình tạo một thực thể chỉ có dữ liệu cho mục đích CRUD.

Đó là lý do tại sao microservices architectures là hoàn hảo cho cách tiếp cận multi-architectural, bạn sẽ lựa chọn phương pháp cụ thể cho từng Bounded Context. Ví dụ, trong eShopOnContainers, ordering microservice triển khai theo DDD patterns, nhưng catalog microservice nó chỉ đơn giản là một CRUD service. 



