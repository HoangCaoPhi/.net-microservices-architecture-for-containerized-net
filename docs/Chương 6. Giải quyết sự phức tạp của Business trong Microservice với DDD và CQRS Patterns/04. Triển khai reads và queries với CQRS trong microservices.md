Để reads/queries, ordering microservice từ ứng dụng eShopOnContainers triển khai queries độc lập với DDD model và transactional. Việc triển khai này cần thiết bởi vì yêu cầu queries và transactions rất khác nhau. 

Khi thực thi các transactions cho hoạt động "write" phải tuân thủ những ràng buộc của domain logic. Mặt khác, "query" là những idempotent có thể tách biệt những quy tắc của domain logic.

Cách tiếp cận này đơn giản, như ở hình 7-3 phía dưới. API interface được triển khai bởi Web API controllers bằng cách sử dụng bất kì infrastructure nào, ví dụ như là micro ORM như Dapper, và trả về ViewModels dynamic tùy thuộc vào nhu cầu của UI app.

![image.png](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/media/cqrs-microservice-reads/simple-approach-cqrs-queries.png)

Hình 7-3. Cách tiếp cận đơn giản của queries trong một CQRS microservice

Cách tiếp cận query-side là idempotent, chúng không thay đổi trạng thái của hệ thống hay dữ liệu được lưu trên cơ sở dữ liệu dùng query bao nhiêu lần đi chăng nữa. Vì vậy, bạn không cần ràng buộc bởi bất kỳ DDD pattern nào sử dụng trong một transaction, và đó là lý do tại sao queries được tách biệt khỏi những transaction. Bạn chỉ query lấy dữ liệu mà UI cần và trả về một dynamic ViewModel mà không cần xác định chúng ở đâu (không có lớp nào cho ViewModels) ngoại trừ trong chính các câu lệnh SQL.

Vì cách tiếp cận này đơn giản, nên mã code ở phía queries side (ví dụ sử dụng Dapper) có thể để trong cùng project API như [ví dụ sau](https://github.com/dotnet-architecture/eShopOnContainers/blob/main/src/Services/Ordering/Ordering.API/Application/Queries/OrderQueries.cs). Hình 7.4 sẽ minh họa rõ hơn cách tiếp cận này. Thư mục Queries được định nghĩa trong project microservice Ordering.API bên trong eShopOnContainers solution:
![image.png](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/media/cqrs-microservice-reads/ordering-api-queries-folder.png)

Hình 7.4. Quries trong Order Microservice trong eShopOnContainers

### Sử dụng ViewModels trả về dữ liệu cho client apps, độc lập với những ràng buộc từ domain model

Vì queries thực hiện để lấy dữ liệu cần thiết cho client apps, loại dữ liệu trả về có thể tạo riêng cho các clients, dựa trên dữ liệu trả về từ các queries. Với những models này hay là các Data Transfer Objects (DTOs) được gọi là ViewModels.

Dữ liệu trả về (ViewModel) có thể là kết quả của việc join nhiều entites hoặc nhiều table trong database, hoặc thâm chí từ nhiều aggregate được định nghĩa trong Domain Model trong phạm vi một transactions. Trong trường hợp này, bởi vì bạn tạo các queries độc lập với domain model, nên các aggregates boundaries và các ràng buộc của nó bị bỏ qua và bạn có thể tự do query bất kỳ cột hay bảng nào bạn cần. Cách tiếp cận này mang lại sự linh hoạt và năng suất cao cho các nhà phát triển khi tạo hoặc cập nhật các truy vấn.

ViewModels có thể là một type được định nghĩa trong một class [như được triển khai ở ordering microservice](https://github.com/dotnet-architecture/eShopOnContainers/blob/main/src/Services/Ordering/Ordering.API/Application/Queries/OrderViewModel.cs). Hoặc chúng có thể được tạo [dạng dynamic](https://github.com/dotnet-architecture/eShopOnContainers/blob/main/src/Services/Ordering/Ordering.API/Application/Queries/OrderQueries.cs) dựa trên các truy vấn được thực hiện, điều này rất linh hoạt đối với các nhà phát triển.

### Sử dụng Dapper làm micro ORM để thực hiện truy vấn

Bạn có thể sử dụng bất kỳ micro ORM, Entity Framework Core hoặc thậm chí ADO.NET để truy vấn. Trong ứng dụng mẫu, Dapper được chọn cho ordering microservice trong eShopOnContainers là một ví dụ điển hình cho một micro ORM. Nó có thể chạy plain SQL với hiệu năng cao, bởi vì nó là một light framework. Sử dụng Dapper bạn có thể viết một SQL query có thể truy vấn vào tables và join nhiều tables trong database.

Dapper là một dự án mã nguồn mở ban đầu được tạo ra bởi Sam Saffron, và là một trong những thành phần cơ bản được sử dụng trong [Stack Overflow](https://stackoverflow.com/). Để sử dụng Dapper, bạn cần cài đặt nó thông qua [Dapper NuGet package](https://www.nuget.org/packages/Dapper), như thể hiện trong hình sau:
![image.png](https://learn.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/media/cqrs-microservice-reads/drapper-package-nuget.png)

Bạn cũng cần thêm directive using trong code của bạn để truy cập các Dapper extension methods.

Khi sử dụng Dapper trong code của bạn, bạn trực tiếp sử dụng trực tiếp lớp [SqlConnection](https://learn.microsoft.com/en-us/dotnet/api/microsoft.data.sqlclient.sqlconnection?view=sqlclient-dotnet-standard-5.2) có sẵn trong namespace [Microsoft.Data.SqlClient](https://learn.microsoft.com/en-us/dotnet/api/microsoft.data.sqlclient?view=sqlclient-dotnet-standard-5.2).Thông qua phương thức QueryAsync và các extension methods khác trong lớp SqlConnection bạn có thể chạy queries một cách đơn giản, trực tiếp và hiệu năng cao.

### ViewModels static và ViewModels dynamic

Khi trả về ViewModels từ server-side cho client apps, bạn có thể nghĩ ViewModels là những DTOs (Data Transfer Objects) nó có thể khác những domain entities của bạn, bởi vì nó chỉ chứa những dữ liệu mà client cần. Vì vậy, trong nhiều trường hợp, bạn có thể tổng hợp dữ liệu từ nhiều entities và đặt chúng vào ViewModels những dữ liệu cần thiết cho client.

Những ViewModels hoặc DTOs có thể định nghĩa rõ ràng  (dưới dạng các class chứa dữ liệu), như là class OrderSummary ở những đoạn code ở phía dưới. Hoặc, bạn chỉ có thể trả về dynamic ViewModels hoặc dynamic DTOs khi bạn muốn tạo các đối tượng mà không cần định nghĩa trước các thuộc tính của chúng. Kiểu dữ liệu động rất linh hoạt và hữu ích khi cấu trúc dữ liệu có thể thay đổi hoặc không xác định trước.

#### ViewModel là một dynamic type

Như được hiển thị trong đoạn code dưới đây, một ViewModel có thể là một dynamic type và trực tiếp trả về bởi queries dựa trên những thuộc tính trả về bởi query. Có nghĩa là, tập hợp những thuộc tính được trả về dựa trên chính query đó. Vì vậy, nếu bạn thêm một cột và query hoặc join, dữ liệu đó được tự động thêm vào và trả về ViewModels:

``` csharp
using Dapper;
using Microsoft.Extensions.Configuration;
using System.Data.SqlClient;
using System.Threading.Tasks;
using System.Dynamic;
using System.Collections.Generic;

public class OrderQueries : IOrderQueries
{
    public async Task<IEnumerable<dynamic>> GetOrdersAsync()
    {
        using (var connection = new SqlConnection(_connectionString))
        {
            connection.Open();
            return await connection.QueryAsync<dynamic>(
                @"SELECT o.[Id] as ordernumber,
                o.[OrderDate] as [date],os.[Name] as [status],
                SUM(oi.units*oi.unitprice) as total
                FROM [ordering].[Orders] o
                LEFT JOIN[ordering].[orderitems] oi ON o.Id = oi.orderid
                LEFT JOIN[ordering].[orderstatus] os on o.OrderStatusId = os.Id
                GROUP BY o.[Id], o.[OrderDate], os.[Name]");
        }
    }
}
```

Điểm quan trọng ở đây là bằng cách sử dụng dynamic type, dữ liệu trả về sẽ được xem là những ViewModel.

Ưu điểm:

Nhược điểm: